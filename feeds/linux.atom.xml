<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>MetaPipe - linux</title><link href="http://www.metapipe.com/" rel="alternate"></link><link href="localhost:8000/feeds/linux.atom.xml" rel="self"></link><id>http://www.metapipe.com/</id><updated>2017-05-10T19:08:51-06:00</updated><entry><title>Shell Basics ForÂ Artists</title><link href="http://www.metapipe.com/blog/posts/2017/05/10/shell-basics-for-artists/" rel="alternate"></link><published>2017-05-10T19:08:51-06:00</published><updated>2017-05-10T19:08:51-06:00</updated><author><name>Liz Benard</name></author><id>tag:www.metapipe.com,2017-05-10:/blog/posts/2017/05/10/shell-basics-for-artists/</id><summary type="html">&lt;p&gt;&lt;span class="dquo"&gt;&amp;#8220;&lt;/span&gt;Don&amp;#8217;t be shell shocked; the terminal ain&amp;#8217;t that scary!&amp;#8221; A basic understanding of how to get around and find and move files is invaluable to an artist in the &lt;span class="caps"&gt;VFX&lt;/span&gt;/Animation industry (or any industry, if you ask&amp;nbsp;me).&lt;/p&gt;</summary><content type="html">&lt;p&gt;The terminal is pretty daunting. All that basically-formatted text, those
sometimes extensive commands, and so much typing make for a barrier to entry
that many artists find hard to get over. But a basic understanding of how to get
around and find and move files is invaluable. And since Unix/Linux has a long
&lt;a href="/blog/posts/2017/03/28/history-of-linux-in-vfx-and-animation/"&gt;history in the industry&lt;/a&gt;, you&amp;#8217;ll probably have to become familiar with
it&amp;nbsp;eventually.&lt;/p&gt;
&lt;p&gt;I have one example from my experience which will hopefully inspire you to power
through this basic guide and expand your&amp;nbsp;repertoire:&lt;/p&gt;
&lt;p&gt;My file browser showed two folders, &amp;#8220;&lt;strong&gt;w&lt;/strong&gt;all&amp;#8221; and &amp;#8220;&lt;strong&gt;W&lt;/strong&gt;all.&amp;#8221; Fine. But when I
tried to click on &amp;#8220;Wall,&amp;#8221; it would disappear and only &amp;#8220;wall&amp;#8221; would remain. I was
thoroughly confused. Thankfully, the terminal showed both folders and let me
look at their contents. Since there was only ever supposed to be &amp;#8220;wall,&amp;#8221; anyway,
I moved all the files over from &amp;#8220;Wall&amp;#8221; and deleted&amp;nbsp;it.&lt;/p&gt;
&lt;p&gt;Apparently, there exist file browsers (I won&amp;#8217;t say which for now; that&amp;#8217;s for
another discussion) which ignore the case of a file or folder&amp;#8217;s name and act
strangely when they encounter files with differing case. There are ways to get
around this issue without the terminal, but it was so much quicker to verify the
problem and fix it with the power of the&amp;nbsp;shell.&lt;/p&gt;
&lt;p&gt;I&amp;#8217;ll be talking about the bash shell, but these simple commands should apply to
most standard *nix shells. Windows&amp;#8217; shell is a different beast, and we&amp;#8217;re not
going to cover that here, but some of the basic commands here exist in&amp;nbsp;PowerShell.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Getting to the&amp;nbsp;shell&lt;/h2&gt;
&lt;p&gt;This depends on your system, of course. I get to mine by going to the
Application menu and searching for &amp;#8220;Terminal.&amp;#8221; It is sometimes filed under
something like&amp;nbsp;&amp;#8220;Administration.&amp;#8221;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Terminal Window" src="/static/img/blog/Shell_1.png"&gt;
&lt;em&gt;Terminal&amp;nbsp;window&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;What to&amp;nbsp;expect&lt;/h2&gt;
&lt;p&gt;Your shell probably looks different from mine, but here are some things to look
out for as we go through&amp;nbsp;this.&lt;/p&gt;
&lt;h3&gt;Is it &amp;#8220;Terminal&amp;#8221; or&amp;nbsp;&amp;#8220;Shell?&amp;#8221;&lt;/h3&gt;
&lt;p&gt;People often use &amp;#8220;terminal&amp;#8221; and &amp;#8220;shell&amp;#8221; interchangeably, and I guess I do
too. Technically, the terminal is a program which lets us interact with the
shell, which does the&amp;nbsp;work.&lt;/p&gt;
&lt;h3&gt;Prompt&amp;nbsp;($)&lt;/h3&gt;
&lt;p&gt;In my shell, it&amp;#8217;s a &lt;code&gt;$&lt;/code&gt; after which I can type in commands. When I press
&lt;code&gt;Enter&lt;/code&gt;, the command is run. For&amp;nbsp;example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ hi
hi: &lt;span class="nb"&gt;command&lt;/span&gt; not found
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Here the command &amp;#8220;hi&amp;#8221; isn&amp;#8217;t recognized by the shell, so it tells us. The shell
is all business. &lt;span class="small"&gt;(&lt;a href="https://en.wikipedia.org/wiki/Cowsay"&gt;Ususally.&lt;/a&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;For the purposes of this post, you can type things in your shell that follow the &lt;code&gt;$&lt;/code&gt;,
and other lines are example output of those&amp;nbsp;commands.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class="caps"&gt;NOTE&lt;/span&gt;&lt;/strong&gt;: Often there is more before the &lt;code&gt;$&lt;/code&gt;, like your username, the machine
name, or what folder you&amp;#8217;re in, but for simplicity we&amp;#8217;ll just show the &lt;code&gt;$&lt;/code&gt; in
examples&amp;nbsp;here.&lt;/p&gt;
&lt;h3&gt;Cases &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt;&amp;nbsp;spaces&lt;/h3&gt;
&lt;p&gt;In the shell, &lt;code&gt;Wall&lt;/code&gt; is not the same as &lt;code&gt;wall&lt;/code&gt;, and it won&amp;#8217;t assume to know what
you meant, it&amp;#8217;ll spit out an error or do something you weren&amp;#8217;t expecting (which
is sometimes&amp;nbsp;scary).&lt;/p&gt;
&lt;p&gt;Also, spaces separate options in a command, so if you have
a folder with spaces, you can surround it with&amp;nbsp;quotes.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ls Spaces folder
ls: cannot access &lt;span class="s1"&gt;&amp;#39;Spaces&amp;#39;&lt;/span&gt;: No such file or directory
ls: cannot access &lt;span class="s1"&gt;&amp;#39;folder&amp;#39;&lt;/span&gt;: No such file or directory
$ ls &lt;span class="s2"&gt;&amp;quot;Spaces folder&amp;quot;&lt;/span&gt;
its_just_easier_to_never_put_spaces_into_folder_names.txt  file_names_either.txt
but_sometimes_you_have_to_deal_with_others_mistakes.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Tilde&amp;nbsp;(~)&lt;/h3&gt;
&lt;p&gt;In a path in the shell, the tilde character (~) is an alias for your home
folder. So, for me, &lt;code&gt;~&lt;/code&gt; is equivalent to &lt;code&gt;/home/ebenard&lt;/code&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Where you&amp;nbsp;are&lt;/h2&gt;
&lt;h3&gt;pwd &amp;#8212; print working&amp;nbsp;directory&lt;/h3&gt;
&lt;p&gt;Short for &amp;#8220;print working directory,&amp;#8221; this is like looking at the top of the page
in a book to remind yourself where you&amp;nbsp;are.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;pwd&lt;/span&gt;
/home/ebenard
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;My shell starts me out in my home folder, so this is what I see when I use the
&lt;code&gt;pwd&lt;/code&gt; command. While you&amp;#8217;re moving around the filesystem, it can be helpful to
remind yourself where you&amp;nbsp;are.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;What&amp;#8217;s&amp;nbsp;here&lt;/h2&gt;
&lt;h3&gt;ls &amp;#8212; list&amp;nbsp;files&lt;/h3&gt;
&lt;p&gt;To &lt;strong&gt;list&lt;/strong&gt; the files and folders in our current location, we use this&amp;nbsp;command.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ls
Desktop  Documents  Downloads  Music  Pictures  Public  stuff.py  Videos
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This shows a space-separated list of the contents of the folder we&amp;#8217;re currently
in. There aren&amp;#8217;t many details to this default view, so now might be the time to
talk about command&amp;nbsp;options.&lt;/p&gt;
&lt;h3&gt;Command&amp;nbsp;options&lt;/h3&gt;
&lt;p&gt;When reading documentation about shell commands, you&amp;#8217;ll often see lots of dashes
and letters. These are options, which are essential to understand if you&amp;#8217;re
going to be using the&amp;nbsp;shell.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ls -l --sort size Desktop/
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Here&amp;#8217;s a breakdown of this&amp;nbsp;command:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-l&lt;/code&gt; is an example of a flag-type option. It needs no more information to
    activate the option. In this case, &lt;code&gt;-l&lt;/code&gt; tells the &lt;code&gt;ls&lt;/code&gt; command to output in a
    long format. &lt;span class="caps"&gt;NOTE&lt;/span&gt;: Both flag options and keyword options can have both short and
    long names. For example, &lt;code&gt;-a&lt;/code&gt; and &lt;code&gt;--all&lt;/code&gt; represent the same flag-type option
    (which lists both hidden and normally-visible files), &lt;code&gt;-a&lt;/code&gt; is just quicker to&amp;nbsp;type.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--sort&lt;/code&gt; is an example of a keyword option which takes a value. The next thing
    separated by a space will be that value. In this case, &lt;code&gt;size&lt;/code&gt; is the value for
    the &lt;code&gt;--sort&lt;/code&gt; option, so &lt;code&gt;ls&lt;/code&gt; will sort the output by size, instead of by the
    default, &lt;code&gt;name&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Desktop/&lt;/code&gt; is an example of a positional option. Its position as the first
    option without a keyword option before it makes it the &amp;#8220;first positional option&amp;#8221;
    of the command, which in this case, is the folder of which we&amp;#8217;re trying to list
    the contents. Although other options can be in almost any order, the positional
    options must be in the order the command&amp;nbsp;expects.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I don&amp;#8217;t have anything on my Desktop, but here&amp;#8217;s the output from my home&amp;nbsp;directory:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ls -l --sort size ~/
total &lt;span class="m"&gt;8&lt;/span&gt;
drwxr-xr-x &lt;span class="m"&gt;6&lt;/span&gt; ebenard ebenard &lt;span class="m"&gt;12288&lt;/span&gt; May &lt;span class="m"&gt;10&lt;/span&gt; &lt;span class="m"&gt;12&lt;/span&gt;:01 Downloads
drwxr-xr-x &lt;span class="m"&gt;2&lt;/span&gt; ebenard ebenard  &lt;span class="m"&gt;4096&lt;/span&gt; Apr &lt;span class="m"&gt;17&lt;/span&gt; &lt;span class="m"&gt;03&lt;/span&gt;:16 Desktop
drwxr-xr-x &lt;span class="m"&gt;2&lt;/span&gt; ebenard ebenard  &lt;span class="m"&gt;4096&lt;/span&gt; Apr &lt;span class="m"&gt;17&lt;/span&gt; &lt;span class="m"&gt;03&lt;/span&gt;:16 Documents
drwxr-xr-x &lt;span class="m"&gt;2&lt;/span&gt; ebenard ebenard  &lt;span class="m"&gt;4096&lt;/span&gt; Apr &lt;span class="m"&gt;17&lt;/span&gt; &lt;span class="m"&gt;03&lt;/span&gt;:16 Music
drwxr-xr-x &lt;span class="m"&gt;2&lt;/span&gt; ebenard ebenard  &lt;span class="m"&gt;4096&lt;/span&gt; May &lt;span class="m"&gt;10&lt;/span&gt; &lt;span class="m"&gt;13&lt;/span&gt;:39 Pictures
drwxr-xr-x &lt;span class="m"&gt;2&lt;/span&gt; ebenard ebenard  &lt;span class="m"&gt;4096&lt;/span&gt; Apr &lt;span class="m"&gt;17&lt;/span&gt; &lt;span class="m"&gt;03&lt;/span&gt;:16 Public
drwxr-xr-x &lt;span class="m"&gt;2&lt;/span&gt; ebenard ebenard  &lt;span class="m"&gt;4096&lt;/span&gt; Apr &lt;span class="m"&gt;17&lt;/span&gt; &lt;span class="m"&gt;03&lt;/span&gt;:16 Videos
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You can see here that it formed the output into a columned list, and
&lt;code&gt;Downloads&lt;/code&gt;, which is the largest (at 12288 bytes), is sorted to the top. The
columns preceding &lt;code&gt;ebenard&lt;/code&gt; are showing &lt;strong&gt;r&lt;/strong&gt;ead/&lt;strong&gt;w&lt;/strong&gt;rite/e&lt;strong&gt;x&lt;/strong&gt;ecute
permissions, which are important, but outside the scope for us here&amp;nbsp;today.&lt;/p&gt;
&lt;h3&gt;less &amp;#8212; view contents of a&amp;nbsp;file&lt;/h3&gt;
&lt;p&gt;This command can be used to see the contents of a plain-text file. &lt;code&gt;stuff.py&lt;/code&gt; is
in this directory, so we&amp;#8217;ll look at it by using this&amp;nbsp;command.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ less stuff.py
&lt;span class="c1"&gt;#! /usr/bin/env python&lt;/span&gt;

print&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Hello world!&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
stuff.py &lt;span class="o"&gt;(&lt;/span&gt;END&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;It shows the first &amp;#8220;page,&amp;#8221; and then you can use the spacebar to page through the
contents. It&amp;#8217;ll tell you what page you&amp;#8217;re on at the bottom (or &amp;#8220;&lt;span class="caps"&gt;END&lt;/span&gt;&amp;#8221; if you&amp;#8217;ve
reached the end). At any time, you can press &lt;code&gt;q&lt;/code&gt; to exit back to the&amp;nbsp;prompt.&lt;/p&gt;
&lt;h3&gt;Launching&amp;nbsp;programs&lt;/h3&gt;
&lt;p&gt;To launch external programs from the terminal, usually we just type the program
name at the prompt and hit&amp;nbsp;enter.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ firefox
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Which will launch Firefox as if you had clicked the entry in the Application
menu. When we go back to our terminal, though, we don&amp;#8217;t have a prompt to keep
working at. To get the prompt back, we have to close&amp;nbsp;Firefox.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class="caps"&gt;TIP&lt;/span&gt;&lt;/strong&gt;: To prevent a launched program like Firefox from holding our prompt
hostage, when we launch it we can add a space and the ampersand &lt;code&gt;&amp;amp;&lt;/code&gt; after the&amp;nbsp;command.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ firefox &lt;span class="p"&gt;&amp;amp;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If we want to edit &lt;code&gt;stuff.py&lt;/code&gt; in an external program, we&amp;#8217;ll have to know the
program&amp;#8217;s name. My basic text editor is &amp;#8220;xed,&amp;#8221; another common one on Linux is
&amp;#8220;gedit.&amp;#8221; To open &lt;code&gt;stuff.py&lt;/code&gt; in xed, I&amp;#8217;d type the&amp;nbsp;following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ xed stuff.py &lt;span class="p"&gt;&amp;amp;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Which opens a xed window with the &lt;code&gt;stuff.py&lt;/code&gt; file opened and ready for editing.
Since we used the ampersand (&lt;code&gt;&amp;amp;&lt;/code&gt;), we can continue using our terminal window
without closing the text&amp;nbsp;editor.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Getting&amp;nbsp;around&lt;/h2&gt;
&lt;h3&gt;cd &amp;#8212; change&amp;nbsp;directory&lt;/h3&gt;
&lt;p&gt;To move around folders, we use &lt;code&gt;cd&lt;/code&gt; to &lt;strong&gt;change directories&lt;/strong&gt;. If we want to get
to the Downloads folder, we&amp;#8217;d type the&amp;nbsp;following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;cd&lt;/span&gt; Downloads
$ &lt;span class="nb"&gt;pwd&lt;/span&gt;
/home/ebenard/Downloads
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Which moves us to the Downloads folder. We can check by using &lt;code&gt;pwd&lt;/code&gt;. We can also
specify a whole path to change&amp;nbsp;to.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;cd&lt;/span&gt; /home/ebenard
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You can specify any path to change to if you have permission to access it.
Typing all this can be very tedious, though. So now is probably a good time to
talk about auto-complete with the tab&amp;nbsp;key.&lt;/p&gt;
&lt;h3&gt;Auto-complete&lt;/h3&gt;
&lt;p&gt;If you don&amp;#8217;t know what something is called, or even if you do, you can use the
tab key to auto-complete a command or path. If there are more than one option,
it won&amp;#8217;t auto-complete, but if you press tab again, the options will be&amp;nbsp;listed.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;cd&lt;/span&gt; D &lt;span class="o"&gt;[&lt;/span&gt;tab&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;tab&lt;span class="o"&gt;]&lt;/span&gt;
Desktop/  Documents/  Downloads/
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We can use this to find what we want and continue typing until pressing tab&amp;nbsp;auto-completes.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;cd&lt;/span&gt; De &lt;span class="o"&gt;[&lt;/span&gt;tab&lt;span class="o"&gt;]&lt;/span&gt;
$ &lt;span class="nb"&gt;cd&lt;/span&gt; Desktop/
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Relative&amp;nbsp;paths&lt;/h3&gt;
&lt;p&gt;If we want to move up a folder without specifying the whole path from the top,
we can use &lt;code&gt;../&lt;/code&gt; to go up a&amp;nbsp;level.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;pwd&lt;/span&gt;
/home/ebenard/Desktop
$ &lt;span class="nb"&gt;cd&lt;/span&gt; ../
$ &lt;span class="nb"&gt;pwd&lt;/span&gt;
/home/ebenard
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The &lt;code&gt;../&lt;/code&gt; represents the parent folder of the one we&amp;#8217;re currently in. If we
wanted to move up several levels, we can use &lt;code&gt;../&lt;/code&gt; in series. For&amp;nbsp;example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;cd&lt;/span&gt; ../../
$ &lt;span class="nb"&gt;pwd&lt;/span&gt;
/
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;span class="caps"&gt;NOTE&lt;/span&gt;&lt;/strong&gt;: Where &lt;code&gt;../&lt;/code&gt; represents the parent folder, &lt;code&gt;./&lt;/code&gt; represents the folder
we&amp;#8217;re currently in. So trying to &lt;code&gt;cd ./&lt;/code&gt; won&amp;#8217;t move us anywhere, since we&amp;#8217;re
specifying the folder we&amp;#8217;re&amp;nbsp;in.&lt;/p&gt;
&lt;h2&gt;Making your&amp;nbsp;mark&lt;/h2&gt;
&lt;h3&gt;mkdir &amp;#8212; make&amp;nbsp;directory&lt;/h3&gt;
&lt;p&gt;If we want to create a folder to keep our &lt;code&gt;.py&lt;/code&gt; file in, we can use &lt;code&gt;mkdir&lt;/code&gt; to
make a directory called &amp;#8220;Code&amp;#8221; (after &lt;code&gt;cd&lt;/code&gt;ing back to our home&amp;nbsp;folder).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ mkdir Code
$ ls
Code  Desktop  Documents  Downloads  Music  Pictures  Public  stuff.py  Videos
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If we want to make another folder inside &lt;code&gt;Code&lt;/code&gt;, maybe &amp;#8220;Python,&amp;#8221; we can do that,
even without moving into the &lt;code&gt;Code&lt;/code&gt; folder.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ mkdir Code/Python
$ ls Code/
Python
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;mv &amp;#8212;&amp;nbsp;move&lt;/h3&gt;
&lt;p&gt;Now if we want to move our &lt;code&gt;stuff.py&lt;/code&gt; file into the &lt;code&gt;Code/Python/&lt;/code&gt;folder, we
would use the &lt;code&gt;mv&lt;/code&gt; command.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ mv stuff.py Code/Python/
$ &lt;span class="nb"&gt;cd&lt;/span&gt; Code/Python/
$ ls
stuff.py
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The &lt;code&gt;mv&lt;/code&gt; command takes two positional options: source and&amp;nbsp;destination.&lt;/p&gt;
&lt;p&gt;One way we can use this command is to rename a file. For example, if we decided
that &lt;code&gt;stuff.py&lt;/code&gt; was a woefully non-descriptive&amp;nbsp;name.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ mv stuff.py hello.py
$ ls
hello.py
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;cp &amp;#8212;&amp;nbsp;copy&lt;/h3&gt;
&lt;p&gt;To copy files or folders around, we can use the &lt;code&gt;cp&lt;/code&gt; command. It takes a source
and destination, just like the &lt;code&gt;mv&lt;/code&gt; command.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ cp hello.py new_hello.py
$ ls
hello.py  new_hello.py
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;At some point we may want to copy a whole folder of stuff. To do this we have to
use the &amp;#8220;recursive&amp;#8221; option (after we &lt;code&gt;cd&lt;/code&gt; out of the &lt;code&gt;Code&lt;/code&gt; folder).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;cd&lt;/span&gt; ../../
$ ls
Code  Desktop  Documents  Downloads  Music  Pictures  Public  Videos
$ cp -r Code/ New_Code/
$ ls
Code  Desktop  Documents  Downloads  Music  New_Code  Pictures  Public  Videos
&lt;/pre&gt;&lt;/div&gt;


&lt;hr&gt;
&lt;h2&gt;Cleaning&amp;nbsp;up&lt;/h2&gt;
&lt;h3&gt;rm &amp;#8212;&amp;nbsp;remove&lt;/h3&gt;
&lt;p&gt;To remove individual files, use the &lt;code&gt;rm&lt;/code&gt; command with the path to the file after a&amp;nbsp;space.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ rm Code/Python/new_hello.py
$ ls Code/Python/
hello.py
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We can remove all the files in a folder using a &amp;#8220;wildcard,&amp;#8221; which will match an
arbitrary number of characters. For&amp;nbsp;example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ rm New_Code/Python/*.py
$ ls New_Code/Python/
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;span class="caps"&gt;BEWARE&lt;/span&gt;&lt;/strong&gt;: The asterisk is a dangerous thing if used unwisely. If you use &lt;code&gt;rm *&lt;/code&gt;
it&amp;#8217;ll remove every file in the current folder. Useful for clearing things out,
but bad if you didn&amp;#8217;t mean to delete everything. Combined with the recursive
option explained below, this is extra dangerous. &lt;strong&gt;Be careful&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;If we want to use &lt;code&gt;rm&lt;/code&gt; to delete folders and their entire contents, you can use
the &amp;#8220;recursive&amp;#8221; option, &lt;code&gt;-r&lt;/code&gt;. &lt;strong&gt;Be careful&lt;/strong&gt; with this as well, since it will
remove everything in and including the folder that you&amp;nbsp;specify.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ rm -r New_Code
$ ls
Code  Desktop  Documents  Downloads  Music  Pictures  Public  Videos
$ rm -r Code
$ ls
Desktop  Documents  Downloads  Music  Pictures  Public  Videos
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;While you&amp;#8217;re getting used to how the terminal and the &lt;code&gt;rm&lt;/code&gt; command work, and
especially when you&amp;#8217;re using the recursive option explained above, the &lt;code&gt;-i&lt;/code&gt;
(interactive) option for &lt;code&gt;rm&lt;/code&gt; can be useful. It will ask you every step of the
way if it should continue. So, if you have a folder called &lt;code&gt;test&lt;/code&gt; with a file
called &lt;code&gt;thing.txt&lt;/code&gt; in it, you can combine &lt;code&gt;-r&lt;/code&gt; and &lt;code&gt;-i&lt;/code&gt; to get the following
step-by-step&amp;nbsp;process:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ rm -r -i &lt;span class="nb"&gt;test&lt;/span&gt;
rm: descend into directory &lt;span class="s1"&gt;&amp;#39;test&amp;#39;&lt;/span&gt;? y
rm: remove regular file &lt;span class="s1"&gt;&amp;#39;test/thing.txt&amp;#39;&lt;/span&gt;? y
rm: remove directory &lt;span class="s1"&gt;&amp;#39;test&amp;#39;&lt;/span&gt;? n
$ ls
Desktop  Documents  Downloads  Music  Pictures  Public  &lt;span class="nb"&gt;test&lt;/span&gt;  Videos
$ rm -r -i &lt;span class="nb"&gt;test&lt;/span&gt;
rm: remove directory &lt;span class="s1"&gt;&amp;#39;test&amp;#39;&lt;/span&gt;? y
$ ls
Desktop  Documents  Downloads  Music  Pictures  Public  Videos
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This will almost definitely get annoying after you&amp;#8217;ve become comfortable with
the shell, but it is very useful to understand how &lt;code&gt;rm&lt;/code&gt; moves through the
folders and&amp;nbsp;files.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;I hope this quick intro was useful to get you started in the shell. Even if you
don&amp;#8217;t use it day-to-day, being familiar with the structure and concepts can open
up methods of getting things done that weren&amp;#8217;t available&amp;nbsp;before.&lt;/p&gt;</content><category term="linux"></category><category term="tech"></category><category term="shell"></category></entry><entry><title>The History of Linux in VFX andÂ Animation</title><link href="http://www.metapipe.com/blog/posts/2017/03/28/history-of-linux-in-vfx-and-animation/" rel="alternate"></link><published>2017-03-28T08:31:00-06:00</published><updated>2017-03-28T08:31:00-06:00</updated><author><name>Aaron Estrada</name></author><id>tag:www.metapipe.com,2017-03-28:/blog/posts/2017/03/28/history-of-linux-in-vfx-and-animation/</id><summary type="html">&lt;p&gt;Nearly all high-end &lt;span class="caps"&gt;VFX&lt;/span&gt; shops use Linux. Why? In this jaunt down the rabbit hole we explore the history of &lt;span class="caps"&gt;C.G.&lt;/span&gt;I production and how we ended up where we are today. I also talk a little bit about why a studio might specifically choose Linux as a choice for large scale&amp;nbsp;production.&lt;/p&gt;</summary><content type="html">&lt;p&gt;People often seem surprised when I tell them that effectively all
high-end &lt;span class="caps"&gt;VFX&lt;/span&gt; and animation shops use
&lt;a href="https://en.wikipedia.org/wiki/Linux"&gt;Linux&lt;/a&gt;. Surely something like
Windows or &lt;span class="caps"&gt;OSX&lt;/span&gt; would be more convenient, right? Maybe so&amp;#8230; or maybe
not. As &lt;a href="/blog/author/ethan-estrada/"&gt;Ethan&lt;/a&gt;
mentioned in an &lt;a href="/blog/posts/2017/03/03/why-linux-for-vfx/"&gt;earlier post&lt;/a&gt;, Linux has some distinct advantages when
deployed at scale and in a pipeline vs traditional desktop operating
systems like Windows and &lt;span class="caps"&gt;OSX&lt;/span&gt;. Also, ignoring the history behind how
the high-end shops ended up where they are today would dismiss a
critical part of the overall story. Animation and &lt;span class="caps"&gt;VFX&lt;/span&gt; shops donât only
use Linux for the advantages it offers today, there is a certain
amount of legacy behind the choice. Letâs look at the&amp;nbsp;history.&lt;/p&gt;
&lt;p&gt;Almost all of the larger &lt;span class="caps"&gt;C.G.&lt;/span&gt; shops started back in the Unix days,
some of them before Windows or Mac &lt;span class="caps"&gt;OS&lt;/span&gt; even existed. The earliest
&lt;span class="caps"&gt;C.G.&lt;/span&gt; studios were even using Lisp based machines and supercomputers
with custom OSes. Most of those studios no longer exist. Regardless,
the legacy of the older studios and the development of &lt;span class="caps"&gt;IT&lt;/span&gt; in general
impact how we do things&amp;nbsp;today.&lt;/p&gt;
&lt;p&gt;&lt;span class="caps"&gt;TRON&lt;/span&gt; was released in 1982, over 35 years ago! At the time, 3D
&lt;span class="caps"&gt;C.G.I.&lt;/span&gt; required a supercomputer to&amp;nbsp;render.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Image of Cray-1 Supercomputert" src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/6e/Cray_1_IMG_9126.jpg/640px-Cray_1_IMG_9126.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Pictured above is a &lt;a href="https://en.wikipedia.org/wiki/Cray-1"&gt;Cray-1&lt;/a&gt;
Supercomputer. One of these was used to render the &lt;span class="caps"&gt;C.G.I.&lt;/span&gt; in &lt;span class="caps"&gt;TRON&lt;/span&gt;. In
1977 this machine cost $5M - $8M depending on the options ordered. It
had 32MBytes of &lt;span class="caps"&gt;RAM&lt;/span&gt;, ran at 80 MHz and provided 160 &lt;span class="caps"&gt;MFLOPS&lt;/span&gt; of compute
power. To put that in perspective, assuming you have a relatively new
smartphone, the &lt;span class="caps"&gt;ARM&lt;/span&gt; &lt;span class="caps"&gt;CPU&lt;/span&gt; in your phone almost certainly provides over 1
GigaFlop. (Thatâs 1000 &lt;span class="caps"&gt;MFLOPS&lt;/span&gt;!) of computing power. It most likely has
1 or more &lt;span class="caps"&gt;GIGABYTES&lt;/span&gt; of &lt;span class="caps"&gt;RAM&lt;/span&gt;. Think about that. Your phone is more
powerful than the &lt;span class="caps"&gt;SUPERCOMPUTER&lt;/span&gt; (at the time) used to render
&lt;span class="caps"&gt;TRON&lt;/span&gt;. More amazingly, itâs likely more powerful than the computers
used to render even Jurassic Park!  Imagine how powerful modern &lt;span class="caps"&gt;PC&lt;/span&gt;
hardware is by&amp;nbsp;comparison.&lt;/p&gt;
&lt;p&gt;Of course, back when the hardware required to render 3D &lt;span class="caps"&gt;C.G.I.&lt;/span&gt; filled
a room and cost over $5 million, the desktop computers of the same era
were not even close to being up to the task. There was no 3D hardware
acceleration and the CPUs were not 32bit. Most did not have any
provision for calculating floating point math in hardware, which is a
critical feature for 3D rendering at any reasonable speed. &lt;span class="caps"&gt;RAM&lt;/span&gt; was
still incredibly expensive and the home computers of the era were only
8 or 16 bit. Even if the &lt;span class="caps"&gt;RAM&lt;/span&gt; were affordable, they couldnât address
very much of it. They were essentially toys compared to the computers
used to do computer graphics at the time. Windows didnât even exist
and neither did Mac &lt;span class="caps"&gt;OS&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Anyone who has heard of
&lt;a href="https://en.wikipedia.org/wiki/Moore's_law"&gt;Moore&amp;#8217;s Law&lt;/a&gt; knows there
is an exponential pace of improvement in the state of the art in
computer science. Computer graphics requires large amounts of compute,
and for years, the cost of compute seemed high. After the era of the
mainframes and supercomputers for the production of &lt;span class="caps"&gt;C.G.&lt;/span&gt; came the era
of the minicomputer and &amp;#8220;workstation&amp;#8221;. These machines were still
expensive but at least they fit in the same room as the
artist. Relative to the mainframes and supercomputers they replaced
for doing &lt;span class="caps"&gt;C.G.&lt;/span&gt; work, they provided a very good performance per
dollar. Most of these machines ran Unix, and this was the era of early
&lt;span class="caps"&gt;C.G.&lt;/span&gt; blockbuster films like Jurassic Park, Terminator 2, and Toy
Story. There was a lot of growth in the &lt;span class="caps"&gt;C.G.&lt;/span&gt; industry in that
period. Not only was animation starting to shift over to computer
graphics, visual effects were driving the demand for photo-real &lt;span class="caps"&gt;C.G.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;In parallel to the development of modern &lt;span class="caps"&gt;C.G.I.&lt;/span&gt; production, the .com
and &lt;span class="caps"&gt;WWW&lt;/span&gt; era of the Internet was maturing.  Unix was building a strong
foothold in the datacenter due to Sun, &lt;span class="caps"&gt;HP&lt;/span&gt;, &lt;span class="caps"&gt;DEC&lt;/span&gt; and &lt;span class="caps"&gt;SGI&lt;/span&gt; servers, which
all ran proprietary Unix variants. The demand for servers to feed the
growing demand for data delivered via the Internet drove the sales of
these computers. It was a less glamourous application of the
technology than C.G., but the higher volumes of machines being sold
helped drive the economy of scale so that the machines were more
affordable for &lt;span class="caps"&gt;C.G.&lt;/span&gt;&amp;nbsp;work.&lt;/p&gt;
&lt;p&gt;&lt;img alt="TUX, the Linux Mascot" src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/35/Tux.svg/280px-Tux.svg.png"&gt;&lt;/p&gt;
&lt;p&gt;By around 1995 Linux,
&lt;a href="https://en.wikipedia.org/wiki/Berkeley_Software_Distribution"&gt;&lt;span class="caps"&gt;BSD&lt;/span&gt; Unix&lt;/a&gt;
and &lt;span class="caps"&gt;PC&lt;/span&gt; hardware were becoming mature enough relative to the established
Minicomputer and âWorkstationâ class machines that some adventurous
Internet server admins began putting parts of their workloads on &lt;span class="caps"&gt;PC&lt;/span&gt;
hardware. Graphic accelerator cards capable of running OpenGL became
available for the &lt;span class="caps"&gt;PC&lt;/span&gt;.  Folks in the &lt;span class="caps"&gt;VFX&lt;/span&gt; and animation business noticed
this. Home computers were no longer toy-like. They supported 32 bit
processors with integrated floating point units, could accept large
amounts of &lt;span class="caps"&gt;RAM&lt;/span&gt; and be networked via ethernet to connect with high
performance network attached storage. They were getting good enough to
compete with the workstation class machines and clusters of them
worked well for making inexpensive render&amp;nbsp;farms.&lt;/p&gt;
&lt;p&gt;The demand for home computers commoditized the &lt;span class="caps"&gt;PC&lt;/span&gt; and helped drive the
&lt;span class="caps"&gt;PC&lt;/span&gt; revolution. The economy of scale possible when selling commodity &lt;span class="caps"&gt;PC&lt;/span&gt;
hardware allowed for better R&amp;amp;D budgets than what the workstation and
minicomputer vendors could match. &lt;span class="caps"&gt;PC&lt;/span&gt; hardware was catching up with
workstation class hardware and actually started to surpass it in many
ways.  By around 1997, when Linux had begun to really mature,
commodity &lt;span class="caps"&gt;PC&lt;/span&gt; hardware had begun to outpace the minicomputer and
&amp;#8220;workstation&amp;#8221; class stuff from the likes of Sun, &lt;span class="caps"&gt;SGI&lt;/span&gt;, &lt;span class="caps"&gt;HP&lt;/span&gt; and &lt;span class="caps"&gt;IBM&lt;/span&gt;.  The
new &lt;span class="caps"&gt;PC&lt;/span&gt; hardware was sufficiently faster (per dollar spent) than the
&amp;#8220;workstation&amp;#8221; and &amp;#8220;minicomputer&amp;#8221; class stuff from the legacy vendors
that the economics could no longer be ignored. Running Linux on the
new &lt;span class="caps"&gt;PC&lt;/span&gt; hardware was the obvious choice because all the custom software
(after re-compilation) and automation scripts they had created over
the years for Unix would just keep working as usual. Porting the
custom code over to a &lt;span class="caps"&gt;NON&lt;/span&gt;-Unix-Like &lt;span class="caps"&gt;OS&lt;/span&gt; would have been a huge chore
but tweaking it for Linux (which is mostly Posix compliant) was a much
less difficult task. Plus, all the artists at the shops knew and
trusted Unix-like systems. At the time, Windows was for playing video
games and doing spreadsheets, not making &lt;span class="caps"&gt;C.G.&lt;/span&gt; for feature films.  A
little bit of trivia&amp;#8230; I worked at one shop that even still used &lt;span class="caps"&gt;CSH&lt;/span&gt;
(rather than the more modern Bash shell or a more robust scripting
language like Python) due to still having so much automation that was
still dependent on &lt;span class="caps"&gt;CSH&lt;/span&gt;. Legacy support was definitely part of the
equation when making the switch to Linux from proprietary Unix&amp;nbsp;variants.&lt;/p&gt;
&lt;p&gt;So, thatâs a quick history of how we ended up where we are. But does
that mean we only use Linux today because we are stuck supporting some
old legacy code from the stone ages? Far from it! I have to agree with
&lt;a href="/blog/posts/2017/03/03/why-linux-for-vfx/"&gt;Ethan&lt;/a&gt; that even
today, Unix-like OSes are more suitable for large scale deployments
and automation. There is a reason nearly the entire Internet and
your smartphone run Linux or some flavor of Unix. What works at scale
for the Internet of course also works at scale for
&lt;span class="caps"&gt;C.G.&lt;/span&gt; production. The standard system shell and file system semantics
alone completely smoke anything on Windows.  Scripting languages like
Python are first class citizens and there is a wealth of Free Open
Source Software available to help address just about any conceivable
need. Basically, with Linux you have some great building blocks for
creating large systems. Plus, the larger the render farm, the more you
save when running Linux vs Windows (While &lt;span class="caps"&gt;OSX&lt;/span&gt; is based on Unix, it
isn&amp;#8217;t an option since Apple doesn&amp;#8217;t license the &lt;span class="caps"&gt;OS&lt;/span&gt; alone. Itâs not
possible to run &lt;span class="caps"&gt;OSX&lt;/span&gt; in the cloud.) Netbooting Linux is more straight
forward than Windows also, which makes managing huge fleets of
machines&amp;nbsp;easier.&lt;/p&gt;
&lt;p&gt;Linux supports most of the high end &lt;span class="caps"&gt;DCC&lt;/span&gt; applications a &lt;span class="caps"&gt;C.G.&lt;/span&gt; artist
might want to use but a few notable examples, like Photoshop, are
missing. At present, this is really the only negative of using Linux
vs using something else. Of course, the same could be said for any
&lt;span class="caps"&gt;OS&lt;/span&gt;. There is always some killer app missing from any given
platform. (Final Cut is missing from Windows, &lt;span class="caps"&gt;3DS&lt;/span&gt; Max is missing on
&lt;span class="caps"&gt;OSX&lt;/span&gt;,&amp;nbsp;etc.)&lt;/p&gt;
&lt;p&gt;If you are an aspiring &lt;span class="caps"&gt;VFX&lt;/span&gt; artist I recommend you learn enough Linux
to at least get around in it. Consider learning Python and possibly
some more advanced shell scripting. Assuming your other skills are
solid, a working knowledge of Linux will help you stand out as an
artist &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; &lt;span class="caps"&gt;TD&lt;/span&gt;.&lt;/p&gt;</content><category term="Linux"></category><category term="tech"></category><category term="explainer"></category></entry><entry><title>Why use Linux for VFX?</title><link href="http://www.metapipe.com/blog/posts/2017/03/03/why-linux-for-vfx/" rel="alternate"></link><published>2017-03-03T09:23:54-07:00</published><updated>2017-03-03T09:23:54-07:00</updated><author><name>Ethan Estrada</name></author><id>tag:www.metapipe.com,2017-03-03:/blog/posts/2017/03/03/why-linux-for-vfx/</id><summary type="html">&lt;!-- A version of this content was first posted on: https://www.quora.com/In-the-VFX-industry-why-would-some-studios-use-UNIX/answer/Ethan-Estrada?srid=Dmy6 --&gt;

&lt;p&gt;When this question is asked, the question between the lines is really
&amp;#8220;Why don&amp;#8217;t they use Windows?&amp;#8221; since the only other real contender
outside Linux is Apple &lt;span class="caps"&gt;OSX&lt;/span&gt;, which itself is based on &lt;span class="caps"&gt;BSD&lt;/span&gt; Unix. For
most intents and purposes, Unix and Linux are pretty&amp;nbsp;interchangeable.&lt;/p&gt;
&lt;p&gt;Only very small â¦&lt;/p&gt;</summary><content type="html">&lt;!-- A version of this content was first posted on: https://www.quora.com/In-the-VFX-industry-why-would-some-studios-use-UNIX/answer/Ethan-Estrada?srid=Dmy6 --&gt;

&lt;p&gt;When this question is asked, the question between the lines is really
&amp;#8220;Why don&amp;#8217;t they use Windows?&amp;#8221; since the only other real contender
outside Linux is Apple &lt;span class="caps"&gt;OSX&lt;/span&gt;, which itself is based on &lt;span class="caps"&gt;BSD&lt;/span&gt; Unix. For
most intents and purposes, Unix and Linux are pretty&amp;nbsp;interchangeable.&lt;/p&gt;
&lt;p&gt;Only very small boutique shops and freelancers use &lt;span class="caps"&gt;MS&lt;/span&gt; Windows
exclusively, and I have found that this confounds young artists new to
the industry as well as veterans who have only ever worked at smaller
shops. The ease of use and ease of intitial set up of &lt;span class="caps"&gt;MS&lt;/span&gt; Windows seem
like home runs to a lot of artists, and so they are left scratching
their heads. While I could focus on the historical reasons for Unix
use , I would rather talk specifically about a few technical reasons
why building a pipeline on Linux/Unix is relatively easy, whereas
doing the same on Windows is downright painful, if not outright
unfeasible. Perhaps I will encourage &lt;a href="/team/"&gt;Aaron&lt;/a&gt;
to make a post about the historical set of reasons for using
Unix. When I say &amp;#8220;Unix&amp;#8221; from here on out, it also includes Linux,
unless otherwise&amp;nbsp;stated.&lt;/p&gt;
&lt;h3&gt;1. Support for symbolic&amp;nbsp;links&lt;/h3&gt;
&lt;p&gt;Unix has had solid support for symbolic links for decades. Windows has
barely added this in Vista, and even then it is still not very good
(and, no, shortcuts are &lt;span class="caps"&gt;NOT&lt;/span&gt; the same thing as symbolic links). Why
would you want symbolic links you ask? Well, let&amp;#8217;s look at a toy
pipeline for the answer (this will be massively oversimplified and is
a poor pipeline model, but works for demonstration). Let&amp;#8217;s say our
system is very simple: for a given shot in a show, we have a
directory that holds all of our files (scene, geometry, textures, the
current version of the plates from the client, etc.). This directory
is a version number. So our directory looks somthing like&amp;nbsp;this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;/proj/seq/shot
    &lt;span class="m"&gt;001&lt;/span&gt;
    &lt;span class="m"&gt;002&lt;/span&gt;
    &lt;span class="m"&gt;003&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Every time we want to version up, we copy the latest version and
renumber it. Dandy! Now what is the problem that happens when our
scene file (let&amp;#8217;s say it is Maya) is versioned up from v2 to v3? All
the file paths still point to v2! Now your supervisor is going to be
angry because you didn&amp;#8217;t update your geometry of that one creature for
your scene. &amp;#8220;But I did, I swear I did!&amp;#8221; you screech in
desperation. Well, it doesn&amp;#8217;t matter that you updated the geometry
file in version 3, because your scene file was still pointed to the
version 2 geometry file. This may seem like an easy fix to do by hand,
but it gets irritating once you are on version 50 and still doing it
over and over and over again. Also, once you are referencing dozens or
hundreds of things into your scene, it simply becomes unfeasible to do
by hand&amp;nbsp;anymore.&lt;/p&gt;
&lt;p&gt;So, what is a simple solution? We write a simple script for versioning
up. It does the copy operation we previously did by hand, but it also
adds one more thing: a symbolic link called &amp;#8220;current&amp;#8221;. So now our
directory looks like&amp;nbsp;this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;/proj/seq/shot
    &lt;span class="m"&gt;001&lt;/span&gt;
    &lt;span class="m"&gt;002&lt;/span&gt;
    &lt;span class="m"&gt;003&lt;/span&gt;
    current -&amp;gt; &lt;span class="m"&gt;003&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And we always work out of current. We make sure all of our referenced
file paths point through current as well. If we need to go back to a
previous version, we make sure to change the &amp;#8220;current&amp;#8221; sym link to
point there first. We would probably do this through some sort of &amp;#8220;job
in&amp;#8221; script so, again, we wouldn&amp;#8217;t need to do this by hand each&amp;nbsp;time.&lt;/p&gt;
&lt;p&gt;Again, this is a simplified example, but these sorts of things happen
all the time in a real production&amp;nbsp;pipeline.&lt;/p&gt;
&lt;h3&gt;2. Atomic file&amp;nbsp;renames&lt;/h3&gt;
&lt;p&gt;By atomic, I mean the operation either fails or succeeds. There is no
in between state; the file can&amp;#8217;t be partially renamed. Along with
this, renames will overwrite other existing files. This is a dual
edged sword since you do need to be careful, but you have the power to
do so when you need&amp;nbsp;it.&lt;/p&gt;
&lt;p&gt;Lets use python to show this example. In Unix systems, if I want to
rename a file, all I do is&amp;nbsp;this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;
&lt;span class="c1"&gt;# I don&amp;#39;t care if the destination file exists, just clobber it&lt;/span&gt;
&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rename&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;some_temp_file.obj&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;final_file.obj&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This previous command will only fail if I don&amp;#8217;t have access to the
file system where these file(s) exist, or I don&amp;#8217;t have permission to
modify them. But, barring that, it will&amp;nbsp;work.&lt;/p&gt;
&lt;p&gt;If you try to rename over a file that already exists in Windows, it
will fail with an error, no matter what. Thus, renames cannot ever be
truly atomic. The only hope on windows is to do one of the following
(neither of which is very&amp;nbsp;good):&lt;/p&gt;
&lt;p&gt;First&amp;nbsp;solution:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;shutil&lt;/span&gt;
&lt;span class="c1"&gt;# uh-oh, our file is corrupt if we fail partway through&lt;/span&gt;
&lt;span class="n"&gt;shutil&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;copy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;some_temp_file.obj&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;final_file.obj&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Second&amp;nbsp;solution:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;
&lt;span class="c1"&gt;# I sure hope this OTHER temp file doesn&amp;#39;t already exist&lt;/span&gt;
&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rename&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;final_file.obj&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;some_other_temp_file.obj&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# someone else could still recreate this file before I have a chance to rename it.&lt;/span&gt;
&lt;span class="c1"&gt;# Better known as a race condition. In windows, it is unavoidable in this situation.&lt;/span&gt;
&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rename&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;some_temp_file.obj&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;final_file.obj&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;remove&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;some_other_temp_file.obj&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;3. Powerful built in file&amp;nbsp;permissions&lt;/h3&gt;
&lt;p&gt;Yes, yes, windows has solutions for this using access lists and other
such things when doing network logins, but they are far removed from
the average or even the technical user, which is most &lt;span class="caps"&gt;VFX&lt;/span&gt;
artists. Also, they are not a built in part of the &lt;span class="caps"&gt;OS&lt;/span&gt;. Windows was not
built with networking in mind; it was bolted on after the fact and it
shows. Windows was not built as a multi-user &lt;span class="caps"&gt;OS&lt;/span&gt;; again, bolted on
after the fact and it shows. Unix has always been multi-user since the
very beginning. Networking became a part of Unix before Windows (or &lt;span class="caps"&gt;MS&lt;/span&gt;
&lt;span class="caps"&gt;DOS&lt;/span&gt; for that matter) even existed. Thus, both are extremely mature and
fairly&amp;nbsp;standardized.&lt;/p&gt;
&lt;h3&gt;4. Mount points for networked drives can be&amp;nbsp;anywhere&lt;/h3&gt;
&lt;p&gt;On windows they need to be on a lettered drive, or using a network
share mount. On Unix, you never need to even know it is a network
mount. Thus it can easily be swapped out later without totally
breaking things. With pipelines that are ever evolving, but still need
to maintain some backwards compatibility, this is a huge boon. As a
case in point, during university, I worked at a small shop on
campus that used Windows. At one point, the &lt;span class="caps"&gt;IT&lt;/span&gt; folks at the shop decided we all needed
to move from the &lt;code&gt;S:&lt;/code&gt; drive to the &lt;code&gt;K:&lt;/code&gt; drive for our network
shares. Needless to say, pretty much all of our scene files&amp;nbsp;broke.&lt;/p&gt;
&lt;h4&gt;Conclusion&lt;/h4&gt;
&lt;p&gt;There are other things that make Unix easier to work with in
production pipelines, but the above are the biggest ones
&lt;span class="caps"&gt;IMHO&lt;/span&gt;. Hopefully some of the appeal is a bit clearer to you now than it
was before. If not, send an email to
&lt;a href="mailto:info@metapipe.com"&gt;info@metapipe.com&lt;/a&gt;. The message should make
its way to me and I&amp;#8217;ll do what I can to answer your&amp;nbsp;questions.&lt;/p&gt;</content><category term="Linux"></category><category term="tech"></category><category term="explainer"></category></entry></feed>